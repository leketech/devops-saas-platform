name: Infrastructure & Application CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  AWS_REGION: us-east-1
  TF_VAR_region: us-east-1

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.8.0
        terraform_wrapper: false

    - name: Terraform fmt
      run: terraform fmt -check
      working-directory: ./infrastructure/terraform

    - name: Lint Terraform
      run: |
        terraform init -backend=false
        terraform validate
      working-directory: ./infrastructure/terraform

    - name: Security scan Terraform files for misconfigurations
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'config'
        scan-ref: './infrastructure/terraform'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        severity: 'CRITICAL,HIGH'
      continue-on-error: false

    - name: Lint YAML files
      run: |
        if command -v yamllint >/dev/null 2>&1; then
          find . -name "*.yml" -o -name "*.yaml" -exec yamllint {} \;
        else
          echo "yamllint not found, installing..."
          pip install yamllint
          find . -name "*.yml" -o -name "*.yaml" -exec yamllint {} \;
        fi

    - name: Lint shell scripts
      run: |
        if command -v shellcheck >/dev/null 2>&1; then
          find . -name "*.sh" -exec shellcheck {} \;
        else
          echo "shellcheck not found, installing..."
          sudo apt-get update && sudo apt-get install -y shellcheck
          find . -name "*.sh" -exec shellcheck {} \;
        fi

  unit-tests:
    runs-on: ubuntu-latest
    needs: lint
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.21'

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.8.0
        terraform_wrapper: false

    - name: Run Go tests
      run: |
        go test -v ./application/...
      working-directory: .

    - name: Run Terraform tests
      run: |
        terraform init -backend=false
        terraform validate
        # Run any terraform tflint tests if available
        # tflint --init
        # tflint
      working-directory: ./infrastructure/terraform

  docker-build:
    runs-on: ubuntu-latest
    needs: unit-tests
    # Only run if there are application files to build
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Check if Dockerfile exists
      id: check_dockerfile
      run: |
        if [ -f "Dockerfile" ]; then
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Build Docker image
      if: steps.check_dockerfile.outputs.exists == 'true'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: false
        tags: saas-platform-app:${{ github.sha }}
        cache-from: type=local,src=/tmp/.buildx-cache
        cache-to: type=local,dest=/tmp/.buildx-cache-new

    # Move cache to correct location
    - name: Move cache
      if: steps.check_dockerfile.outputs.exists == 'true'
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache

    # Create a sample Dockerfile if one doesn't exist for testing purposes
    - name: Create sample Dockerfile
      if: steps.check_dockerfile.outputs.exists == 'false'
      run: |
        echo "FROM nginx:1.26.1" > Dockerfile
        echo "COPY . /usr/share/nginx/html" >> Dockerfile
        cat Dockerfile

    - name: Build sample Docker image
      if: steps.check_dockerfile.outputs.exists == 'false'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: false
        tags: saas-platform-app:${{ github.sha }}
        cache-from: type:local,src=/tmp/.buildx-cache
        cache-to: type=local,dest=/tmp/.buildx-cache-new

  trivy-scan:
    runs-on: ubuntu-latest
    needs: docker-build
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner in repo mode
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Run Trivy security scan for critical CVEs in filesystem
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        severity: 'CRITICAL'
      continue-on-error: false

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'

    - name: Run Trivy vulnerability scanner on Docker image
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'image'
        image-ref: 'saas-platform-app:${{ github.sha }}'
        format: 'table'
        exit-code: '1'
        ignore-unfixed: true
        vuln-type: 'os,library'
        severity: 'CRITICAL'
      continue-on-error: false

  push-to-ecr:
    runs-on: ubuntu-latest
    needs: trivy-scan
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Check if Dockerfile exists
      id: check_dockerfile
      run: |
        if [ -f "Dockerfile" ]; then
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Create Dockerfile if needed
      if: steps.check_dockerfile.outputs.exists == 'false'
      run: |
        echo "FROM nginx:1.26.1" > Dockerfile
        echo "COPY . /usr/share/nginx/html" >> Dockerfile

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        IMAGE_NAME: saas-platform-app
      run: |
        docker build -t $ECR_REGISTRY/$IMAGE_NAME:$IMAGE_TAG .
        docker tag $ECR_REGISTRY/$IMAGE_NAME:$IMAGE_TAG $ECR_REGISTRY/$IMAGE_NAME:latest
        docker push $ECR_REGISTRY/$IMAGE_NAME:$IMAGE_TAG
        docker push $ECR_REGISTRY/$IMAGE_NAME:latest
        echo "image=$ECR_REGISTRY/$IMAGE_NAME:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Output image details
      run: |
        echo "Pushed image: ${{ steps.build-image.outputs.image }}"

    - name: Logout of Amazon ECR
      if: always()
      run: docker logout ${{ steps.login-ecr.outputs.registry }}